---
title: "Углубляемся в C++"
---

## Знаковый и беззнаковые типы
Да, они всё же есть. Например, в прошлой статье у нас был тип `size_t`, который хранит размер того или иного контейнера, и очевидно, что в контейнере не может лежать отрицательное число элементов, поэтому и `size_t` хранит только неотрицательные числа.
Рассмотрим на примере `int`:
По стандарту языка `int` должен быть не менее 4 байт(но может быть и больше, например, 6), следовательно в нём могут лежать значения в диапазоне `[-2.147.483.648; +2.147.483.647]`(но диапазон может быть и шире).
```cpp
int main()
{
    int a = -2'147'483'648;
    int b = +2'147'483'647;
    // C++ позволяет разделять большие числа апострофами для лучшей читаемости
}
```

И как нам быть, если нас абсолютно не интересуют отрицательные числа? Например, мы храним число секунд с какого-то события. Первый вариант - взять ещё больший тип данных, чтобы в него влезло побольше положительных чисел, но в нём всё равно будут отрицательные, которые нас не интересуют - так себе решение. Можно взять `size_t` - бинго! Вот только...а как этот `size_t` работает? Как из него исчезли все отрицательные числа? А вот и ответ: если приписать спереди от типа данных слово `unsigned`, то тип уже не сможет хранить в себе отрицательные числа, но зато диапазон для положительных расширяется вдвое(`[0; 4.294.967.295]`)!
```cpp
int main()
{
    unsigned int a = 0;
    unsigned b = 4'294'967'295; // компилятор поймёт, что b - unsigned int, - поэтому int лучше опустить, чтобы не засорять код
}
```

Кстати, здесь мы будет получать предупреждение компилятора о неиспользуемых переменных.

## Переполнение
Переполнение - очень скользкий момент, зависящий от конкретных настроек компилятора. В упрощённом случае - числовой диапазон можно представить в форме кольца, за максимальным значением которого сразу же идёт минимальное. Например, в случае с типом `unsigned`(`unsigned int`):
```cpp
int main()
{
    unsigned a = 4'294'967'295;
    ++a;
    // теперь переменная равна нулю
}
```

## Привратности математики
Проверим наши знания в арифметике?
```cpp
#include <iostream>

int main()
{
    std::cout << 3 * 4 << std::endl; // 12
    std::cout << 3 / 4 << std::endl; // 0
}
```
Как нуль? 0.75 ведь...но нет. Рассмотрим повнимательнее. Операцию деления можно записать так: `lhs / rhs = result`. `lhs` и `rhs` имеют тип `int`, значит и `result` будет иметь тип `int`. По сути, мы поделили нацело на 4.
Это всё хорошо, но как получить 0.75? Всё очень просто - нужно чтобы хотя бы один операнд(или оба) был типа, поддерживающего операции с плавающей запятой. Например, пусть `lhs` будет `double`: `3.0 / 4`, или же пусть `rhs` будет `float`: `3 / 4.f`, или же оба пусть будут `double`: `3.0 / 4.0`.
Хорошо, а что будет в таком случае: `3.0 / 4.f`? 0.75, хотя так лучше и не делать, ибо очень сложно с ходу сказать, какого же типа будет результат: `float` или `double`? Правильный ответ - `double`, т.к. его диапазон шире, чем у `float`, но это достаточно неочевидный момент, лучше постараться его избегать.

## Пара слов о `main`
Если вы внимательный читатель, то могли заметить, что в коде выше отсутствуют вызовы `return` из функции `main`, и при этом компилятор почему-то не ругается...Как так? В прошлой статье я говорил, что функция `main` особенная. Например, из неё можно не делать `return`. На самом-то деле о ней можно писать достаточно много, но это всё такие тонкости, которые скорее относятся к приятным мелочам. А потому мы будем делать `return` из `main` лишь в какой-то аварийной ситуации, и возвращать мы будем, конечно же, не нуль(который говорит, что программа успешно отработала), а любое другое целое число.

## Грабельки для тех, кто переходит с JS/Python, или в чём же разница между ссылкой и значением
В JS/Python мы привыкли, что если передать примитивный тип(например, boolean, number) в функцию, то она передастся по значению, т.е. изменения её внутри функции не приведут к изменениям снаружи, а сложные объекты, переданные внутрь функции(например, массивы) будут изменены снаружи при изменении внутри функции, - это передача по ссылке.
Исходя из заголовка - в C++ всё не так. Программист сам решает, как ему принимать данные - по ссылке или по значению. Здесь будет немного кода, сопровождаемого комментариями:
```cpp
struct Vector2
{
public:
    double x = 0;
    double y = 0;
}

void DoSthByValue(Vector2 v)
{
  // можем делать с вектором всё, что душе угодно, изменений снаружи не будет
  // по факту, значение v будет скопировано снаружи, создастся новый Vector2, который и будет нам передан
}

void DoSthByConstValue(const Vector2 v)
{
  // изменить вектор уже не получится, соответственно и изменений снаружи не будет
  // аналогично предыдущему, создастся новый Vector2, но изменять его мы уже не можем
  // не используется на практике
}

void DoSthByReference(Vector2 & v)
{
  // можем делать с вектором всё, что душе угодно, будут изменения снаружи
}

void DoSthByConstReference(const Vector2 & v)
{
  // изменять вектор не можем
  // в отличие от DoSthByConstValue, эта функция не создаёт копию объекта, а потому работает несколько быстрее
  // но не стоит излишне упарываться и передавать примитивные типы(bool, int, etc.) по константной ссылке - это не принесёт выгоды
}
```

Здесь можно провести аналогию с Pascal: там мы писали `VAR` в аргументах функции для передачи по ссылке и ничего не писали для передачи по значению.

## Области видимости
В C++ фигурные скобки являются ещё и своего рода scope'ом(областью видимости).
```cpp
int main()
{
    int a = 0;
    if (true)
    {
        a = 4;
    }
}
```

Здесь мы видим, что переменная, объявленная на первом уровне вложенности(`main`), видна на втором(внутри `if`), пока всё как в JS.

```cpp
int main()
{
    int a = 0;
    if (true)
    {
        int a = 4;
    }
}
```

Здесь же изменится переменная внутри `if`, после `if` значение `a` будет нулём. Однако компилятор выдаст нам предупреждение, потому что мы перекрыли одну переменную другой.

А теперь лайфхак, для которого я отписал всё это выше - можно принудительно задавать область видимости: 

```cpp
int main()
{
    {
        const int a = 4;
    }
    {
        const int a = -11;
    }
    {
        const unsigned a = 95'000'001;
    }
}
```

Никаких ошибок компиляции, никаких предупреждений, - всё законно. Каждая переменная `a` видна лишь внутри своей области видимости, которая обозначена фигурными скобочками.

## Магическое `std::`
Надеюсь, всем уже есть 18.

Чтобы понять, что же такое `std::`, нужно понять, что же такое `namespace`. Допустим, мы пишем какую-то библиотеку для работы с векторами. Мы можем, как в прошлом примере, вынести наш `Vector2` в отдельные файлы, опубликовать их, сказать, что их можно подключать, и на том успокоиться. Однако, нет, не всё так просто. Когда мы так поступим, то мы замусорим пространство имён у пользователей, т.е. если они захотят создать какую-то свою структуру/класс с именем Vector2, то их ожидают ошибки. А мы в нашей библиотеке понасоздавали `Vector3`, `Vector4`, etc. Здесь нам и помогут пространства имён:
```cpp
namespace vl // vectorlibrary - имена у пространств имён всегда чудаковатые
{
    struct Vector2 { /* ... */};
    struct Vector3 { /* ... */};
    struct Vector4 { /* ... */};
}

int main()
{
    const vl::Vector2 v2 = { 0, 0 };
    const vl::Vector3 v3 = { 0, 0, 0 };
    const vl::Vector4 v4 = { 0, 0, 0, 0 };
}
```

Теперь пользователь нашей библиотеки может создавать свои классы и структуры с именами `Vector2`, `Vector3`, `Vector4`, ничто ему в этом мешать не будет. Ну да, будут некоторые проблемы с созданием чего-то с именем `vl`, но как бы...проблема-то одна, а не несколько, да и что вообще такое `vl`?
Кстати, `using namespace::vl` избавит от необходимости писать `vl::`.

Собственно, аналогично поступили и разработчики стандартной библиотеки C++: вынесите `namespace vl` в отдельный файл, переименуйте `vl` в `std`, напишите пару сотен тысяч строк кода логики и получите стандартную библиотеку :)

## Стандартная библиотека слишком велика для запоминания
Очень спокойно забываются те или иные вещи из стандартной библиотеки, потому что она действительно огромна. Зачастую программисты пишут то, что уже есть в стандартной библиотеке, просто потому что не удосужились поискать в ней необходимый функционал. В этом нам помогут такие сайты как:
* [CppReference](http://en.cppreference.com)
* [CPlusPlus](http://cplusplus.com)

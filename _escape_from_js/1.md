---
title: "Как понять основы C++, не написав на нём ни строчки?"
---

Никак. Разумеется, если вы ранее не писали ни на каком другом C-подобном языке.
Спойлер: JS является C-подобным.
Однако, как оказалось, почти все основы мы уже знаем, нужно только освежить знания, поехали!

## Разворачиваем окружение
* Ставим Git
* Ставим Microsoft Visual Studio Community Edition
* Ставим английский language-pack для VisualStudio(большая часть советов, вопросов-ответов в сети именно на английском)

## Замечание автора
Работоспособность проверена в VisualStudio 2017 и в online-compiler'ах с поддержкой C++17. Были замечены проблемы в сборке в древней VisualStudio 2013, убедительная просьба не заниматься археологией.

Если вы работает на Linux или Mac OS X, то рекомендую QtCreator

## Начало любой программы
Любая программа на языке C++ начинается с функции `main()`
```cpp
int main() // функция с именем main, возвращающая значение типа int(целое знаковое число)
{
    return 0;
}
```

Желательно, чтобы эта функция располагаль в одноимённом файлике - `main.cpp` - и чтобы в нём ничего, кроме этой функции не было, но этим мы на первых порах пренебрежём :)

`main` - особая функция, как минимум потому что без неё ничего не работает и потому что, если она вернёт значение отличное от 0, то считается, что программа завершилась с ошибкой.

## Основные операторы
Структурное программирование как бы намекает, что нам нужны условия и циклы. Не вопрос:
```cpp
int main()
{
    const int d = 101; // целочисленная знаковая константа d
    if (d == 101)
    {
        // ...
    }

    float sth = 128.5f; // число с плавающей запятой [128.5], буква f - float
    while (sth > 10)
    {
        sth /= 2; // можем изменять её значение
    }

    for (int i = 0; i < 100; ++i)
    {
        // ...
    }
}
```

Отличия от JS минимальны, не так ли?

## "А что ещё можно делать на этих ваших плюсах?"
Из коробки - ничего. Но если подключить какую-то библиотеку, то жизнь станет намного ярче. Например, вне зависимости от вашего компилятора, рабочей машины, погоды и времени года у вас будет доступна стандартная библиотека языка C++. Опробуем же её в деле!
```cpp
#include <iostream>

int main()
{
      std::cout << "Hello World" << std::endl;
}
```

Здесь мы с помощью `#include <iostream>` получили доступ к операторам ввода и печати, упрятанным в стандартную библиотеку, отписали "Hello World" и перенесли каретку на новую строку с помощью `endl`. Вот ещё пример:
```cpp
#include <iostream>

int main()
{
    int a, b;
    std::cin >> a >> b; // считали два числа
    std::cout << a + b << std::endl; // вывели их сумму
}
```

Не стоит сейчас заморачиваться на тем, что из себя представляет магическое `std::`, а потому избавим себя от необходимости постоянного писать магию:
```cpp
#include <iostream>

using namespace::std; // перекладываем "магию" со своих плеч на плечи компилятора

int main()
{
    cout << "No magic!" << endl;
}
```

## Свои процедуры и функции
Так уж срослось, что процедур нет. Совсем нет. Кончились. Но можно сделать функцию, которая ничего не возвращает!

```cpp
void PrintHello() // возвращает void, имя - PrintHello
{
    cout << "Hello" << endl;
}
```

Однако, если очень захотеть выйти из "процедуры" досрочно, то можно сделать как-то так:
```cpp
void DoSthSpecial()
{
    if (true)
    {
        return;
    }
    // do sth
}
```

Ну а что касательно функций, то здесь всё по аналогии:
```cpp
double GetPi() // возвращает double - число с плавающей запятой двойной точности
{
    return 3.1415926538979; // буквы f в конце нет
}
```
Сразу заметим, что возвращать можно не только базовые типы(bool, int, float, double, etc.), но и собственные типы данных. Совсем скоро мы в этом убедимся.
И да, функция в любом случае обязана вернуть значение того типа, который указан в её объявлении. Если в коде функции есть такой участок, где она заканчивается, не вернув значение, то компилятор выдаст ошибку. Никаких undefined, всё по-взрослому :)

## Структуры и классы
Отлично! ООП? А вот нет, это другой предмет =)

Здесь мы договоримся, что классы - это какие-то наши объекты, которые содержат в себе какую-то логику, а структуры - лишь обёртка над данными. Например, игрок - это класс, а двумерный вектор - структура.
В классах и структурах бывают поля трёх типов:
* public - видны извне
* private - видны только внутри класса
* protected - магия ООП, опустим магию, магия - это плохо

```cpp
struct Vec2
{
public:
      double x = 0; // инициализировать поля структуры/класса - хороший тон
      double y = 0;
};

class Player
{
public:
    Player(); // конструктор

private:
    Vec2 m_position = {0, 0};
    Vec2 m_size = {0, 0};
};
```

Конструктор? Ну, да. Когда мы создаём экземпляр класса или структуры, то первым делом вызывается конструктор. Всё по аналогии с JS. Да, к слову, конструктор может быть и у структуры, никто никого ни в чём не ограничивает :)
К слову, да, о создании, немного подкорректируем нашего Player и создадим его:

```cpp
class Player
{
public:
    Player(Vec2 position, Vec2 size)
    {
        m_position = position;
        m_size = size;

        cout << "Player was created" << endl; // для примера
    }

private:
    // без изменений
};

int main()
{
    const Player player({10, 10}, {1.5, 2}); // создаём игрока с координатами (10; 10) и размерами 1.5x2
    // в консоль выведется сообщение "Player was created"
    return 0;
}
```
Отлично, мы создали одного игрока. А если нужно двух? А семь? Здесь нужна динамическая память.

## "Умные массивы"
В этом разделе мы познакомимся с "резиновыми" массивами в C++, поехали:

В JS очень удобен метод `push()` у массива, который добавляет в конец ещё один элемент. C++ тоже так умеет, но это уже именуется не массивом, а вектором:
```cpp
#include <vector>
#include <iostream>

using namespace::std;

int main()
{
    vector<int> nums; // объявляем вектор целых знаковых чисел
    nums.push_back(0);
    nums.push_back(4);
    nums.push_back(-1);
    nums.push_back(51);

    for (size_t i = 0; i < nums.size(); ++i) // size_t???
    {
        cout << nums[i] << " "; // 0 4 -1 51
    }
    cout << endl;
    return 0;
}
```

Здесь мы использовали новый для нас тип данных - `size_t`. Очередная плюсовая магия, да. Стандартная библиотека для хранения размеров тех или иных контейнеров(в нашем случае - `vector`) использует тип `size_t`. Он предоставляет по сути целые положительные числа(т.е. натуральные и нуль), и его диапазон позволяет хранить очень-очень большие числа. Мы могли бы написать вместо `size_t` знакомый нам `int`, но это было бы неверно. Например, если бы `int` хранил числа в отрезке [-1; +1], а `size_t` хранил бы [-2; +2], то если бы метод `size()` вернул нам 2, то мы бы пришли к тому, что счётчик цикла у нас бы переполнился после значения +1 и стал бы -1. Очевидно, что -1 меньше 2, начинается следующая итерация, и так вечно, - зацикливание.

Теперь с нашими игроками:
```cpp
#include <vector>

using namespace::std;

// class Player

int main()
{
    vector<Player> players;
    for (int i = 0; i < 5; ++i)
    {
        players.push_back(Player({0, 0}, {0, 0}));
    }
    return 0;
}
```

Создали 5 игроков, отлично! Теперь давайте немного оживим их всех, добавив классу `Player` метод `Say()`. Метод - функция, принадлежая классу.
Например, у вектора(vector) есть метод `back()`, возвращающий последний добавленный элемент. И да, это не JS, в случае, если вызвать `back()` у пустого вектора, то будет совсем не undefined. Будет выброшено исключение, говорящее об исключительной ситуации в программе, и программа аварийно завершится.

```cpp
#include <iostream>
#include <vector>
#include <string>

using namespace::std;

class Player
{
public:
    // без изменений, только добавил метод у класса

    void Say(const string & text)
    {
        cout << text << endl;
    }

private:
    // без изменений
};

int main()
{
    vector<Player> players;
    for (int i = 0; i < 5; ++i)
    {
        players.push_back(Player({0, 0}, {0, 0}));
        players.back().Say("Hello!");
    }
    return 0;
}
```

На выходе имеем 5 игроков, каждый из которых поздоровался.

## Делаем код читабельнее
Возьмём полностью наш предыдущий листинг кода из файла main.cpp:
```cpp
#include <iostream>
#include <vector>
#include <string>

using namespace::std;

struct Vec2
{
public:
      double x = 0;
      double y = 0;
};

class Player
{
public:
    Player(Vec2 position, Vec2 size)
    {
        m_position = position;
        m_size = size;
    }

    void Say(const string & text)
    {
        cout << text << endl;
    }

private:
    Vec2 m_position = {0, 0};
    Vec2 m_size = {0, 0};
};

int main()
{
    vector<Player> players;
    for (int i = 0; i < 5; ++i)
    {
        players.push_back(Player({0, 0}, {0, 0}));
        players.back().Say("Hello!");
    }
    return 0;
}
```

Выглядит как-то жестоко, не так ли? Какое отношение к функции main имеют структура Vec2 и класс Player? Стоит разнести их по разным файлам! Начнём со структуры: создадим файл `Vec2.h`

Внимание! Файлы в нашем случае должны располагаться рядом с `main.cpp`

```cpp
#pragma once // эта строка поможет компилятору быстрее собрать проект, если Vec2 подключается более чем в одном месте. Где один - там и два, так что пишем обязательно

struct Vec2
{
public:
      double x = 0;
      double y = 0;
};
```

Теперь займёмся классом Player, создадим `Player.h`:
```cpp
#pragma once

#include "Vec2.h" // подключаем наш Vec2; внимание на двойные кавычки - не угловые скобки

#include <string>

using namespace::std; // запомните эту строку, скоро мы её раскритикуем

class Player
{
public:
    Player(Vec2 position, Vec2 size)
    {
        m_position = position;
        m_size = size;
    }

    void Say(const string & text)
    {
        cout << text << endl;
    }

private:
    Vec2 m_position = {0, 0};
    Vec2 m_size = {0, 0};
};
```

Здесь стоит остановиться и осмотреться. Почему в include кавычки? Всё очень просто, если написать через угловые скобки, то файл сначала поищется среди стандартной библиотеки, если не найдётся, то поищется в нашей директории, если не найдётся - ошибка сборки.
Второе замечание - "хашники"(\*.h файлы) созданы для элегантного объявления классов, их методов и прочей красоты, а здесь ещё и реализация, как так?
И увы, в хашниках не стоит писать `using namespace::std`, а потому привет, магическое `std::`; от этого не сбежать, но не беспокойтесь, в следующей статье вы узнаете про `std::`, капельку терпения

```cpp
#pragma once

#include "Vec2.h" // подключаем наш Vec2; внимание на двойные кавычки, не угловые скобки

#include <string>

class Player
{
public:
    Player(Vec2 position, Vec2 size);

    void Say(const std::string & text);

private:
    Vec2 m_position = {0, 0};
    Vec2 m_size = {0, 0};
};
```

Создаём `Player.cpp`, и в нём определяем наши метода, приписав спереди от имени методов через двоеточие имя класса:
```cpp
#include "Player.h"

#include <string>

using namespace::std;

Player::Player(Vec2 position, Vec2 size)
{
    m_position = position;
    m_size = size;
}

void Player::Say(const string & text)
{
    cout << text << endl;
}
```

Отлично!

И в `main.cpp` у нас такая красота:
```cpp
#include "Player.h"

#include <vector>

using namespace::std;

int main()
{
    vector<Player> players;
    for (int i = 0; i < 5; ++i)
    {
        players.push_back(Player({0, 0}, {0, 0}));
        players.back().Say("Hello!");
    }
    return 0;
}
```

# Спойлеры на следующие статьи
Немножко возможностей C++ для более красивого кода и...графика :)
+ раскрытие тайны `std::`
